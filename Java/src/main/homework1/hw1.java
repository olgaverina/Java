public class hw1 {

    public static void main(String[] args) {

//    Сдавайте задание в виде скриншота, пожалуйста. Один скриншот - одно задание.
//    Если кода много - то ссылка на pastebin или ваш гитхаб с дз. В случае с литкодом, скриншот с успешной сдачей вместе с кодом.
//        1. Разобраться с задачей про исполнителя (разбиралась последней на семинаре)
//        2. Попробовать сгенерировать все перестановки длины N из K чисел с повторениями. Пример: N = 2, K = 3 ответ "00 01 02 10 11 12 20 21 22"
//
//    На вход некоторому исполнителю подаётся два числа (a, b). У исполнителя есть две команды
//      - команда 1 (к1): увеличить в с раза, а умножается на c
//      - команда 2 (к2): увеличить на d ( +2 ), к a прибавляется d
//    написать программу, которая выдаёт набор команд, позволяющий число a превратить в число b или сообщить, что это невозможно
//    Пример 1: а = 1, b = 7, c = 2, d = 1
//    ответ: к1, к1, к1, к1, к1, к1 или к1, к2, к1, к1, к1 или к1, к1, к2, к1.
//            Пример 2: а = 11, b = 7, c = 2, d = 1
//    ответ: нет решения.
//            *Подумать над тем, как сделать минимальное количество команд
        int a = 1;
        int b = 11;
        int c = 3; //увеличить в с раза
        int d = 3; //увеличить на d
        int flag;
        int temp = a; //1

        while(temp <= b) {
            flag = 0;
            temp *= c;
            if (temp != b) {
                temp /= c;
                temp += d;
                if (temp <= b)
                    System.out.print(" k2 - " + temp);
                flag = 1;
            }
            if (flag != 1 && temp <= b)
                System.out.print(" k1 - " + temp);
    }
        if (temp != b)
            System.out.println("\nНет решения");
//мне кажется, что операция умножения дает наибОльший шаг и наибыстрое приближение к числу b, поэтому я сначала все время умножала
        // и только потом прибавляла



}}
